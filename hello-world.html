<html><head><style>html{background-color:#ddd;}body{margin:0px;font-size:18px;}#navbar{overflow:hidden;padding-left:20%;}#navbar a{float:left;color:#121212;text-align:center;text-decoration:none;padding:10px 14px;}#navbar a:hover{color:#ff5733;background-color:#222;}#main{top-margin:10px;padding:0px 20%;}#main div{padding:0px 8px;color:#444;background-color:#ddd;float:left;border:1px solid black;box-shadow:0px 4px 24px black;}a{color:#ff5733;text-decoration:none;}h1{text-align:center;}</style></head><body><div id="navbar"><a href="/"><b>home</b></a><a href="https://github.com/haxala1r"><b>GitHub</b></a></div><div id="main"><div><h1> Hello world!</h1><p>This is my first website, built with my very own static website generator! I'm really excited to be able to use what I've built.</p><p>Well, I guess I'll use the rest of this page to tell you a bit more about the benefits and exciting parts of my project.  (also maybe a bit about how satisfied I am with it)</p><h1> What it does</h1><p>From a user standpoint, this project accomplishes three main things:</p><ul><li> Gives you a convenient, easy-to-use and concise interface and [Domain-Specific Language](https://en.wikipedia.org/wiki/Domain-specific_language) to generate HTML and CSS code from Common Lisp code</li><li> Lets you swiftly and painlessly generate HTML code from the Markdown format.</li><li> Combining the two above points, lets you generate an entire website from just a template written in the DSL mentioned in point 1 and HTML code compiled from a Markdown file (as mentioned in point 2). The command-line tool even lets you convert multiple markdown files into websites using the same template!</li></ul><p></p><h1> How it does what it does</h1><p> To get a little more involved with the code, here is how a simple page with a blue "Hello world!" text would look in my HTML DSL:</p><p><code>(html (body (p :attrs (:color "blue") "Hello world!")))</code></p><p>...which generates:</p><p><code>&lt;html&gt;&lt;body&gt;&lt;p color="blue"&gt; Hello world! &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></p><p>Well, at first this may not look any different than regular HTML, but this has a few advantages that regular HTML doesn't:</p><ul><li> It has no closing tags. Just closing parentheses, like normal Common Lisp code.</li><li> Perhaps more importantly, you can execute regular code <i>inside</i> the HTML-generating code. So <code>(p (* 5 5))</code> is equivalent to <code>(p 25)</code>. This also means that File and Network I/O can be done, if necessary.</li><li> Conversely, regular Common Lisp code can also make use of this language. So for example, you can make use of my project to type <code>(print (p (i "hello world!")))</code> at the repl, and that would print "&lt;p&gt;&lt;i&gt;hello world!&lt;/i&gt;&lt;/p&gt;".</li></ul><p> The last two points are especially important, because that's the part that lets us generate static web pages from a template and markdown file, and does so elegantly.</p><p>Essentially, the template is first evaluated as Common Lisp code. The template, while being evaluated (or executed, in this context), executes code that reads and processes the markdown file. However the code that tokenizes, parses and then evaluates the markdown file itself makes use of even more Common Lisp code that generates HTML code, which is how we're able to turn (or <i>compile</i>) <code>*text*</code> into <code>&lt;i&gt;text&lt;/i&gt;</code>.</p><p>It's quite amazing, isn't it?</p><h2> Compiling Markdown</h2><p></p><p>The next big component of my project is the Markdown compiler, which tokenizes, then parses the input markdown into an appropriate AST.</p><p>If you'd like some more details, here's how the transformation goes. Sorry if I'm detailing too much here, but I kind of want to show what I learnt here, so here we go...   - <code>*hello world*</code> is taken as input. - The tokenizer converts this into a list of tokens, each of which is in fact an ast-node object. For this input, the list of tokens would be:  - First, an ast-node containing "*" as its value (because <code>*</code> is a token), and <code>'STAR</code> as its type.  - Second, an ast-node containing "hello world" as its value (there are no special tokens here, so it's treated as text) with <code>'TEXT</code> as its type.  - Third, another star. Same as the first one.  - Lastly, an EOF token is inserted at the end of the token stream. This is always done to ensure the parser knows when the stream is going to end. - This list of tokens is then compared to all known "parsers", which are actually functions that take a list of tokens and return a new ast-node and the remaining tokens. In this case, <code>paragraph-parser</code> is the high-level parser that matches this. - <i>That</i> function internally attempts to match with the parsers for codeblocks, links, bolds, italics etc. etc. until it reaches the one that matches. - The italics parser for example, attempts to match, in order:  - a node that has the type <code>'STAR</code>  - here, it attempts to match (again) codeblocks, links, bolds, regular text etc. etc. until a match is found or fails.  - The above point means that we can accurately parse nested formattings. <i>So <b>we</b> <code>can</code> <a href="https://rickroll.com"><b>have</b></a></i> <b><code>many</code></b> complicated things happen in text, and still be able to parse it properly. This "recursive descent" structure (essentially, the fact that a parser can (and should!) call other parsers (even <i>itself</i>)) is what made it click for me. It's what makes parsing complicated structures like this possible, and I'm glad I started this journey... anyway.  - then, matches another star. If successful so far, return a new <code>'ITALIC</code> node with whatever was in between the stars as its value. - You see the point. This parsing logic keeps continuing until every last token has been matched by something and an AST has been assembled. - After this, the compiler walks through the tree and generates HTML code, using the tools made available in the above section.</p><p>The end result is that you can use this code: <code>(process-markdown-string "*hello **world***")</code></p><p>... and it generates this string: <code>"&lt;p&gt;&lt;i&gt;hello &lt;b&gt;world&lt;/b&gt;&lt;/i&gt;&lt;/p&gt;"</code></p><p>Or, if you think that was too simple of an example, take this page you're viewing right now. Yes, this page (along with the rest of the site) was generated with this very tool, you can view the source (both the markdown and the template) on my GitHub account. </p></div></div></body></html>